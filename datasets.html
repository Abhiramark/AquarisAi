<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aquaris AI - Datasets</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<style>
body { font-family: 'Inter', sans-serif; background-color: #0d0d0d; color: white; }
.container { max-width: 1000px; margin: 2rem auto; padding: 1rem; }
.dataset-viewer { background-color: #1a1a1a; padding: 1.5rem; border-radius: 1rem; margin-top: 1rem; border: 1px solid #333; }
.dataset-item { cursor: pointer; padding: 0.75rem; border-radius: 0.5rem; transition: 0.2s; border-left: 4px solid transparent; }
.dataset-item:hover { background-color: #333; border-left-color: #06b6d4; }
.dataset-item.bg-gray-700 { background-color: #374151; }
.dataset-item.bg-gray-600 { background-color: #4b5563; }
input[type=file] { color: white; }
/* Custom Table Styling */
#datasetTableContainer table { border-collapse: collapse; width: 100%; font-size: 0.8rem; }
#datasetTableContainer th { background-color: #06b6d4; color: black; padding: 0.5rem 1rem; text-align: left; position: sticky; top: 0; z-index: 10; }
#datasetTableContainer td { padding: 0.5rem 1rem; border-bottom: 1px solid #333; word-break: break-word; }
#datasetTableContainer tr:nth-child(even) { background-color: #222; }
#datasetTableContainer tr:hover { background-color: #333; }
</style>
</head>
<body>

<header class="fixed top-0 left-0 w-full bg-gray-900 bg-opacity-90 backdrop-blur-sm z-50 border-b border-gray-700">
Â  Â  <div class="max-w-7xl mx-auto px-4 py-3 flex items-center relative">
Â  Â  Â  Â  <a href="index.html" title="Back to Main Page"
Â  Â  Â  Â  Â  Â class="p-2 rounded-full hover:bg-gray-700 transition absolute left-4">
Â  Â  Â  Â  Â  Â  <svg class="w-6 h-6 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
Â  Â  Â  Â  Â  Â  Â  Â  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
Â  Â  Â  Â  Â  Â  </svg>
Â  Â  Â  Â  </a>
Â  Â  Â  Â  <div class="flex-grow text-center font-bold text-xl text-cyan-400">
Â  Â  Â  Â  Â  Â  Aquaris AI - Datasets
Â  Â  Â  Â  </div>
Â  Â  </div>
</header>

<main class="pt-20 container"> 
Â  Â  <h2 class="text-2xl font-bold mb-4 text-cyan-400">Available Datasets</h2>
Â  Â  <div id="dataset-list" class="space-y-2"></div>

Â  Â  <h2 class="text-2xl font-bold mt-8 mb-4 text-cyan-400">Add a Dataset or ZIP</h2>
Â  Â  <div class="flex items-center p-4 bg-gray-800 rounded-lg">
Â  Â  Â  Â  <input type="file" id="fileInput" accept=".csv,.json,.zip" multiple class="flex-grow file:mr-4 file:py-2 file:px-4
Â  Â  Â  Â  Â  Â  file:rounded-full file:border-0
Â  Â  Â  Â  Â  Â  file:text-sm file:font-semibold
Â  Â  Â  Â  Â  Â  file:bg-cyan-500 file:text-white
Â  Â  Â  Â  Â  Â  hover:file:bg-cyan-600"/>
Â  Â  Â  Â  <button id="uploadBtn" class="bg-cyan-500 px-4 py-2 rounded font-semibold hover:bg-cyan-600 ml-4">Upload</button>
Â  Â  </div>

Â  Â  <div id="message" class="mt-4 text-sm text-gray-400"></div>

Â  Â  <div class="dataset-viewer">
Â  Â  Â  Â  <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
Â  Â  Â  Â  Â  Â  <h3 class="text-xl font-semibold text-gray-300" id="viewerTitle">Dataset Viewer</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="downloadBtn" class="hidden bg-green-600 px-4 py-2 rounded font-semibold hover:bg-green-700 text-white text-sm">
Â  Â  Â  Â  Â  Â  Â  Â  Download File
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  
Â  Â  Â  Â  <div id="datasetTableContainer" class="max-h-[500px] overflow-auto">
Â  Â  Â  Â  Â  Â  <p class="text-gray-500 p-4 text-center">Click on a dataset to view its full content.</p>
Â  Â  Â  Â  </div>
Â  Â  </div>
</main>

<script>
const fileInput = document.getElementById('fileInput');
const uploadBtn = document.getElementById('uploadBtn');
const message = document.getElementById('message');
const datasetList = document.getElementById('dataset-list');
const datasetTableContainer = document.getElementById('datasetTableContainer');
const viewerTitle = document.getElementById('viewerTitle');
const downloadBtn = document.getElementById('downloadBtn');

const RAILWAY_BACKEND_URL = 'https://aquarisai-production.up.railway.app'; // <--- GLOBAL URL CONSTANT
const MAX_ROWS_TO_RENDER = 500; // Safety limit to prevent browser crashes on large files

// --- DATA PARSING AND TABLE GENERATION FUNCTIONS ---

/**
Â * Parses raw file content and generates a full HTML table.
Â */
function displayFullDataset(filename, text) {
Â  Â  let headers = [];
Â  Â  let allRows = []; 
Â  Â  let rowsToDisplay = [];
Â  Â  let totalRowCount = 0;

Â  Â  try {
Â  Â  Â  Â  if (filename.toLowerCase().endsWith('.csv')) {
Â  Â  Â  Â  Â  Â  // Use regex for robust line splitting across different OS line endings
Â  Â  Â  Â  Â  Â  const lines = text.split(/\r?\n/).filter(l => l.trim());
Â  Â  Â  Â  Â  Â  if (lines.length === 0) throw new Error("File is empty.");
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 1. Get Headers
Â  Â  Â  Â  Â  Â  headers = lines[0].split(',').map(h => h.trim());
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 2. Get All Rows
Â  Â  Â  Â  Â  Â  allRows = lines.slice(1).map(line => {
Â  Â  Â  Â  Â  Â  Â  Â  const values = line.split(',');
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure every row has the same number of columns as headers
Â  Â  Â  Â  Â  Â  Â  Â  return values.map(v => v.trim()); 
Â  Â  Â  Â  Â  Â  }).filter(row => row.length === headers.length);

Â  Â  Â  Â  Â  Â  totalRowCount = allRows.length;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  } else if (filename.toLowerCase().endsWith('.json')) {
Â  Â  Â  Â  Â  Â  const json = JSON.parse(text);
Â  Â  Â  Â  Â  Â  if (json.length === 0) throw new Error("JSON file is empty.");

Â  Â  Â  Â  Â  Â  // 1. Get Headers (all unique keys from all objects)
Â  Â  Â  Â  Â  Â  const allKeys = new Set();
Â  Â  Â  Â  Â  Â  json.forEach(obj => {
Â  Â  Â  Â  Â  Â  Â  Â  Object.keys(obj).forEach(key => allKeys.add(key));
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  headers = Array.from(allKeys);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 2. Get All Rows
Â  Â  Â  Â  Â  Â  allRows = json.map(obj => {
Â  Â  Â  Â  Â  Â  Â  Â  return headers.map(header => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const value = obj[header];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Handle null/undefined values
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return value === undefined || value === null ? '' : String(value);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  totalRowCount = allRows.length;

Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  throw new Error(`File type not supported for viewing: ${filename.split('.').pop().toUpperCase()}.`);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  if (totalRowCount === 0) throw new Error("No data rows found.");

Â  Â  Â  Â  // Apply display limit for performance
Â  Â  Â  Â  rowsToDisplay = allRows.slice(0, MAX_ROWS_TO_RENDER);

Â  Â  Â  Â  // --- Generate HTML Table ---
Â  Â  Â  Â  let tableHtml = '<table><thead><tr>';
Â  Â  Â  Â  
Â  Â  Â  Â  // Headers
Â  Â  Â  Â  tableHtml += headers.map(h => `<th>${h}</th>`).join('');
Â  Â  Â  Â  tableHtml += '</tr></thead><tbody>';

Â  Â  Â  Â  // Rows
Â  Â  Â  Â  tableHtml += rowsToDisplay.map(row => {
Â  Â  Â  Â  Â  Â  return '<tr>' + row.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
Â  Â  Â  Â  }).join('');
Â  Â  Â  Â  
Â  Â  Â  Â  tableHtml += '</tbody></table>';
Â  Â  Â  Â  
Â  Â  Â  Â  // Update DOM
Â  Â  Â  Â  datasetTableContainer.innerHTML = tableHtml;
Â  Â  Â  Â  viewerTitle.textContent = `Viewing: ${filename} (${totalRowCount} total rows)`;
Â  Â  Â  Â  
Â  Â  Â  Â  let displayMessage = `Full dataset content loaded for ${filename}.`;
Â  Â  Â  Â  if (totalRowCount > MAX_ROWS_TO_RENDER) {
Â  Â  Â  Â  Â  Â  displayMessage = `Dataset loaded. Display is **limited to the first ${MAX_ROWS_TO_RENDER} rows** for performance. Total rows: ${totalRowCount}.`;
Â  Â  Â  Â  }

Â  Â  Â  Â  message.textContent = displayMessage;
Â  Â  Â  Â  
Â  Â  Â  Â  // Show Download Button
Â  Â  Â  Â  downloadBtn.onclick = () => handleDownload(filename);
Â  Â  Â  Â  downloadBtn.classList.remove('hidden');


Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Data Parsing Error:", err);
Â  Â  Â  Â  
Â  Â  Â  Â  let errorMessage = err.message;
Â  Â  Â  Â  // Specific check for the user-reported error on large files
Â  Â  Â  Â  if (errorMessage.includes("Invalid string length") || errorMessage.includes("Maximum call stack size exceeded")) {
Â  Â  Â  Â  Â  Â  Â errorMessage = `Critical error: File is likely too large (${text.length} chars) for the browser to process. Please use the Download button for the full file.`;
Â  Â  Â  Â  }

Â  Â  Â  Â  viewerTitle.textContent = "Dataset Viewer";
Â  Â  Â  Â  downloadBtn.classList.add('hidden');
Â  Â  Â  Â  datasetTableContainer.innerHTML = `<p class="text-red-400 p-4 text-center">Error: ${errorMessage}</p>`;
Â  Â  Â  Â  message.textContent = `Error opening ${filename}: ${errorMessage}`;
Â  Â  }
}

/**
Â * Handles the file download process.
Â */
function handleDownload(filename) {
Â  Â  const encodedFilename = encodeURIComponent(filename); 
Â  Â  // FIX: Corrected URL to use backticks and point to the dedicated download route
Â  Â  const downloadUrl = `${RAILWAY_BACKEND_URL}/api/datasets/download/${encodedFilename}`;
Â  Â  
Â  Â  // Create a temporary anchor element to trigger the download
Â  Â  const link = document.createElement('a');
Â  Â  link.href = downloadUrl;
Â  Â  link.download = filename; // Suggest the original filename
Â  Â  document.body.appendChild(link);
Â  Â  link.click();
Â  Â  document.body.removeChild(link);
Â  Â  
Â  Â  message.textContent = `Download started for ${filename}.`;
}

// --- FILE LISTING AND FETCHING ---

// Adds a persistent or newly uploaded dataset to list (for single files or ZIPs)
function addDatasetToList(name) {
Â  Â  // MODIFIED: Added flex classes for side-by-side layout of name and download button
Â  Â  const item = document.createElement('div');
Â  Â  item.className = 'dataset-item bg-gray-700 flex justify-between items-center';

Â  Â  // 1. File Name (clickable for viewer)
Â  Â  const nameSpan = document.createElement('span');
Â  Â  nameSpan.textContent = name;
Â  Â  // Using the original click handler logic
Â  Â  nameSpan.onclick = () => handleItemClick(name); 
Â  Â  nameSpan.className = 'flex-grow cursor-pointer hover:text-cyan-300 transition';
Â  Â  
Â  Â  // 2. Download Link (for direct download)
Â  Â  const downloadLink = document.createElement('a');
Â  Â  const encodedFilename = encodeURIComponent(name); 
Â  Â  
Â  Â  // Set the href to the new dedicated download API route
Â  Â  downloadLink.href = `${RAILWAY_BACKEND_URL}/api/datasets/download/${encodedFilename}`;
Â  Â  downloadLink.textContent = 'Download';
Â  Â  downloadLink.target = '_blank'; // Opens in new tab
Â  Â  downloadLink.className = 'bg-cyan-500 text-white text-sm px-3 py-1 rounded hover:bg-cyan-600 transition ml-4';

Â  Â  item.appendChild(nameSpan);
Â  Â  item.appendChild(downloadLink);
Â  Â  datasetList.appendChild(item);
}


// Adds an extracted file from ZIP to list (content is ready for display)
function addZippedDatasetToList(name, content) {
Â  Â  const item = document.createElement('div');
Â  Â  item.className = 'dataset-item bg-gray-600 ml-4';
Â  Â  item.textContent = `-> ${name}`;
Â  Â  item.onclick = () => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // Display full dataset for zipped files
Â  Â  Â  Â  Â  Â  displayFullDataset(name, content);
Â  Â  Â  Â  } catch(err) {
Â  Â  Â  Â  Â  Â  message.textContent = `Error viewing ${name}: ${err.message}`;
Â  Â  Â  Â  }
Â  Â  };
Â  Â  datasetList.appendChild(item);
}

// Function to process content fetched from a ZIP file
async function processZippedContent(zipFilename, arrayBuffer) {
Â  Â  try {
Â  Â  Â  Â  const zip = await JSZip.loadAsync(arrayBuffer);
Â  Â  Â  Â  
Â  Â  Â  Â  // Clear previous list, show the ZIP name
Â  Â  Â  Â  datasetList.innerHTML = `<div class="font-bold text-lg text-cyan-400 mt-4 mb-2">ðŸ“¦ Content of ${zipFilename}:</div>`;

Â  Â  Â  Â  let filesListed = 0;
Â  Â  Â  Â  for (const filename of Object.keys(zip.files)) {
Â  Â  Â  Â  Â  Â  // Check for CSV/JSON files and skip directories
Â  Â  Â  Â  Â  Â  if (filename.endsWith('/') || (!filename.toLowerCase().endsWith('.csv') && !filename.toLowerCase().endsWith('.json'))) continue; 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Extract file content for quick viewing when clicked
Â  Â  Â  Â  Â  Â  const fileData = await zip.files[filename].async('string');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Add the internal file to the visible list with its content logic
Â  Â  Â  Â  Â  Â  addZippedDatasetToList(filename, fileData); 
Â  Â  Â  Â  Â  Â  filesListed++;
Â  Â  Â  Â  }
Â  Â  Â  Â  message.textContent = `Content from ZIP ${zipFilename} loaded successfully. Click a file below to view its content.`;
Â  Â  } catch (err) {
Â  Â  Â  Â  message.textContent = `Error extracting ZIP content: ${err.message}`;
Â  Â  Â  Â  console.error("ZIP Extraction Error:", err);
Â  Â  }
}

// Handler for when a listed file is clicked
async function handleItemClick(filename) {
Â  Â  message.textContent = `Fetching content for ${filename}...`;
Â  Â  try {
Â  Â  Â  Â  // Use URL-encoding to handle spaces/special characters in filenames
Â  Â  Â  Â  const encodedFilename = encodeURIComponent(filename); 
Â  Â  Â  Â  
Â  Â  Â  Â  // FIX: Corrected URL to use backticks (`) and the constant
Â  Â  Â  Â  const response = await fetch(`${RAILWAY_BACKEND_URL}/api/datasets/${encodedFilename}`)
Â  Â  Â  Â  
Â  Â  Â  Â  if (!response.ok) {
Â  Â  Â  Â  Â  Â  Â throw new Error(`Failed to fetch file: ${response.status} (${response.statusText}). Check server logs.`);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  if (filename.toLowerCase().endsWith('.zip')) {
Â  Â  Â  Â  Â  Â  // ZIP: Read as ArrayBuffer and pass to JSZip for extraction
Â  Â  Â  Â  Â  Â  const arrayBuffer = await response.arrayBuffer();
Â  Â  Â  Â  Â  Â  await processZippedContent(filename, arrayBuffer);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // CSV/JSON: Read as text and pass to the display function
Â  Â  Â  Â  Â  Â  const text = await response.text();
Â  Â  Â  Â  Â  Â  displayFullDataset(filename, text);
Â  Â  Â  Â  }

Â  Â  } catch(err) {
Â  Â  Â  Â  console.error("Fetch/Parse Error:", err);
Â  Â  Â  Â  
Â  Â  Â  Â  let errorMessage = err.message;
Â  Â  Â  Â  // Improved error reporting for large file issues
Â  Â  Â  Â  if (errorMessage.includes("Invalid string length") || errorMessage.includes("Maximum call stack size exceeded")) {
Â  Â  Â  Â  Â  Â  Â errorMessage = `Critical error: The file is too large for the browser to process. Please use the Download button for the full file.`;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Reset view when error occurs
Â  Â  Â  Â  viewerTitle.textContent = "Dataset Viewer";
Â  Â  Â  Â  downloadBtn.classList.add('hidden');
Â  Â  Â  Â  datasetTableContainer.innerHTML = `<p class="text-red-400 p-4 text-center">Error opening ${filename}: ${errorMessage}</p>`;
Â  Â  Â  Â  message.textContent = `Error opening ${filename}: ${errorMessage}`;
Â  Â  }
}

// --- PERSISTENCE LOGIC ---

// Fetch the list of files from the server on page load
async function fetchFileList() {
Â  Â  message.textContent = "Loading available datasets...";
Â  Â  datasetList.innerHTML = "";
Â  Â  try {
Â  Â  Â  Â  // FIX: Corrected URL to use backticks (`) and the constant
Â  Â  Â  Â  const response = await fetch(`${RAILWAY_BACKEND_URL}/api/datasets/list`)
Â  Â  Â  Â  if (!response.ok) throw new Error("Failed to connect to backend to retrieve file list.");
Â  Â  Â  Â  
Â  Â  Â  Â  const files = await response.json();
Â  Â  Â  Â  
Â  Â  Â  Â  if (files.length === 0) {
Â  Â  Â  Â  Â  Â  message.textContent = "No datasets found on the server. Upload one to begin.";
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  files.forEach(filename => {
Â  Â  Â  Â  Â  Â  addDatasetToList(filename); // Add to the list with click handler AND download link
Â  Â  Â  Â  });
Â  Â  Â  Â  message.textContent = `${files.length} datasets loaded from server. Click a file name to view its full data.`;

Â  Â  } catch (err) {
Â  Â  Â  Â  console.error(err);
Â  Â  Â  Â  message.textContent = `ERROR: ${err.message}. Ensure server.py is running and accessible.`;
Â  Â  }
}

// Handle uploaded files (sends to backend, then refreshes list)
async function handleFile(file) {
Â  message.textContent = `Uploading file "${file.name}"...`;
Â  Â  
Â  const formData = new FormData();
Â  formData.append('file', file);
Â  Â  
Â  try {
Â  Â  // STEP 1: Upload to Flask backend
Â  Â  // FIX: Corrected URL to use backticks (`) and the constant
Â  Â  const response = await fetch(`${RAILWAY_BACKEND_URL}/api/datasets`,{
Â  Â  Â  method: 'POST',
Â  Â  Â  body: formData
Â  Â  });

Â  Â  const result = await response.json();

Â  Â  if (!response.ok) {
Â  Â  Â  throw new Error(result.message || 'Server upload failed.');
Â  Â  }

Â  Â  // STEP 2: Reload the persistent list to show the new file
Â  Â  await fetchFileList();
Â  Â  
Â  } catch(err) {
Â  Â  console.error("Upload Error:", err);
Â  Â  message.textContent = `Error uploading "${file.name}": ${err.message}`;
Â  }
}


// --- EVENT LISTENERS AND INITIALIZATION ---

uploadBtn.addEventListener('click', () => {
Â  const files = fileInput.files;
Â  if (!files.length) { message.textContent = "Select at least one file."; return; }
Â  
Â  Array.from(files).forEach(file => handleFile(file));
});

// Load files when the page loads (Persistence)
document.addEventListener('DOMContentLoaded', fetchFileList);
</script>
</body>
</html>